    zero
    stsp
    lwv str
    stwr w0
    lbv 90
    arv Prnt2d10
    call
    lwr w0
    ara
    zero
    stbi
    lwv str
    arv PrintStr
    call
    zero
    ara
    out

str: .rep (100) .db 0

; Print a 2-digit (up to 99) decimal number in L to [W0]
; incrementing W0 by 1 or 2. Returns updated W0. Clobbers all other regs
; ----------------------------------------------------------------------
Prnt2d10:
    zxbw
    arv Prnt2d1n
    stwi ; [Prnt2d1n]=number
    stwr w1 ; w1 = number
    arv Prnt2d1p
    lwr w0
    stwi ; [Prnt2d1p]=W0
    lwv 10
    xa
    lwr w1
    sub
    arv Prnt2d1b
    jif xnz ; 1 digit only
    lwr w1
    arv Div2d10
    call ; W3 = div, W0 = rest
    lwr w0
    stwr w1 ; W1 = rest
    arv Prnt2d1p
    lwi
    stwr w2
    ara
    lbr b6 ; lob(W3)
    xa
    lbv '0'
    add
    stbi ; [[Prnt2d1p]]=decimal char
    lwr w2
    xa
    lwv 1
    add
    arv Prnt2d1p
    stwi ; [Prnt2d1p]++
Prnt2d1b: ; W1 = number or rest
    lwr w1
    xa
    lbv '0'
    add
    xa ; X = decimal char
    arv Prnt2d1p
    lwi
    stwr w2
    ara
    xa
    stbi ; [[Prnt2d1p]]=decimal char
    lwr w2
    xa
    lwv 1
    add
    stwr w0
    ret

Prnt2d1n:   .dw 0
Prnt2d1p:   .dw 0

; Divide a 2-digit decimal number (actually up to 159) in L by 10
; Result in W3, Rest in W0. Clobbers all regs
; ---------------------------------------------------------------
Div2d10:
    zxbw    ; make sure we also handle byte inputs
    stwr w0 ; w0 = long division source accumulator
    lbv 80  ; use LBV since H is already 0 anyway
    stwr w1 ; w1 = shifted divider
    lbv 8
    stwr w2 ; w2 = result bit
    zero
    stwr w3 ; w3 = result accumulator
Div2d10l:
    lwr w1
    xa
    lwr w0  ; A = source accum, X = shifted divider
    sub
    arv Div2d10s
    jif xnz
    stwr w0 ; store subtraction result back
    lwr w2
    xa
    lwr w3
    add
    stwr w3 ; add to result
Div2d10s:
    lwr w1
    zxwx
    ror
    stwr w1 ; divider >>= 1
    lwr w2
    ror ; no need to zero X, most of its bits are still zero
    arv Div2d10e
    jif z
    stwr w2 ; result bit >>= 1
    arv Div2d10l
    jmp
Div2d10e:
    ret


; Print Hex Word. Value to print is in A, clobber W0,W1
; -----------------------------------------------------
PrntHexW:
    stwr w1
    xhl
    arv PrntHexB
    call
    lwr w1
    arv PrntHexB
    call
    ret

; Print Hex Byte. Value to print is in A, clobber W0
; --------------------------------------------------
PrntHexB:
    zxbw
    stwr w0
    ror
    ror
    ror
    ror
    arv PrntHexN
    call
    lwr w0
    arv PrntHexN
    call
    ret

; Print Hex Nibble. Value to print is in lowest 4 bits of A
; ---------------------------------------------------------
PrntHexN:
    xa
    lwv $F
    and ; [A] = nibble
    xa ; nibble in X
    lwv 10
    xa
    sub
    arv PrntHxNA
    jif xz
    xa
    lwv '0'+10 ; add 10 back
    add
    arv 1
    out
    ret
PrntHxNA: ; A..F ([A] = nibble-10, clobber X,ADDR)
    xa
    lwv 'A'
    add
    arv 1
    out
    ret

; Print zero-terminated string pointed to by A. Clobbers W1, W0
; -------------------------------------------------------------
PrintStr:
    stwr w1 ; W1 = running_ptr
    ara
    lbi
    arv PrintStx
    jif lz
    arv 1
    out
    lwr w1 ; A = running_ptr
    cxwx ; X = running_ptr
    lwv 1 ; A = 1
    add ; A = ++running ptr
    arv PrintStr
    jmp
PrintStx:
    ret
