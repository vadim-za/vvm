    zero
    stsp

; clear screen
    lwv ClsStr
    arv PrintStr
    call

; draw walls
    zero
    arv DrwWallH
    call
    lbv 23
    arv DrwWallH
    call
    zero
    arv DrwWallV
    call
    lbv 79
    arv DrwWallV
    call

    lwv 2
    ara
    in

    zero
    ara
    out

    lbv 5
    stbr b0
    stbr b2
    arv SetCurXY
    call

    lwv str
    arv PrintStr
    call
    zero
    ara
    out

str: .ds 'String'
    .db 0
    .rep (20) .db 0

ClsStr: ; cls string
    .db $1B
    .ds '[2J'
    .db 0

; Draws horizontal wall. A = vertical pos. Clobbers all registers
DrwWallH:
    stbr b2
    zero
    stbr b0
    arv SetCurXY
    call
    lbv '#'
    stbr b0 ; fill char
    lwv 80
    stwr w1 ; count
DrwWllHa:
    arv 1
    lbr b0
    out
    lwv 1
    xa
    lwr w1
    sub
    stwr w1
    arv DrwWllHa
    jif lnz
    ret

; Draws vertical wall. A = horizontal pos. Clobbers all registers
DrwWallV:
    stbr b0
    zero
    stbr b2
    arv SetCurXY
    call
    lbv '#'
    stbr b0 ; fill char
    lwv 24 ; count
    arv DrwWllVc
    stwi
DrwWllVa:
    arv 1
    lbr b0
    out
    lwv 1
    xa
    arv DrwWllVc
    lwi
    sub
    stwi
    arv DrwWllVe
    jif lz
    lwv CursorLD
    arv PrintStr
    call
    arv DrwWllVa
    jmp
DrwWllVe:
    ret
DrwWllVc: .dw 0

CursorLD: ; cursor left and down
    .db $1B
    .ds '[D'
    .db $1B
    .ds '[B'
    .db 0

; body: 000000dd1 = tail
;       dd bits point to next segmemt: 00 = right, 01 = down, 02 = left, 03 = up
;       head does not use any specific value
; wall: 00000xx1  (xx bits can be anything)
; empty:  00000000
; pickup: 10000000
; size 80x24
field: .rep (1920) .db 0

; Set cursor position. b0=X, b2=Y. Clobbers all registers
; -------------------------------------------------------
SetCurXY:
    lbr b0
    arv SetCurX
    stwi
    lwv SetCurS+2
    stwr w0
    lbr b2 ; A = Y, W0 = SetCurS+2
    xa
    lbv 1
    add ; make 1-based
    arv Prnt2d10
    call ; W0 = incremented ptr
    lwr w0
    ara
    lbv ';'
    stbi
    lwr w0
    xa
    lwv 1
    add ; A = ptr+1
    stwr w0
    arv SetCurX
    lbi ; A = X, W0 = ptr
    xa
    lbv 1
    add ; make 1-based
    arv Prnt2d10
    call ; W0 = incremented ptr
    lwr w0
    ara
    lbv 'f'
    stbi
    lwr w0
    xa
    lwv 1
    add
    ara
    zero
    stbi
    lwv SetCurS
    arv PrintStr
    jmp
SetCurX:
    .dw 0
SetCurS:
    .db $1B
    .ds '[00;00f'
    .db 0


; Print a 2-digit (up to 99) decimal number in L to [W0]
; incrementing W0 by 1 or 2. Clamps the input to 99 for safety.
; Returns updated W0. Clobbers all other regs
; --------------------------------------------------------------
Prnt2d10:
    zxbw
    stwr w1
    xa
    lwv 100
    xa
    sub ; XA = num-100
    arv Prnt2d1r
    jif nz
    lwv 99  ; clamp to 99
    stwr w1
Prnt2d1r:
    lwr w1
    arv Prnt2d1n
    stwi ; [Prnt2d1n]=number
    stwr w1 ; w1 = number
    arv Prnt2d1p
    lwr w0
    stwi ; [Prnt2d1p]=W0
    lwv 10
    xa
    lwr w1
    sub
    arv Prnt2d1b
    jif xnz ; 1 digit only
    lwr w1
    arv Div2d10
    call ; W3 = div, W0 = rest
    lwr w0
    stwr w1 ; W1 = rest
    arv Prnt2d1p
    lwi
    stwr w2
    ara
    lbr b6 ; lob(W3)
    xa
    lbv '0'
    add
    stbi ; [[Prnt2d1p]]=decimal char
    lwr w2
    xa
    lwv 1
    add
    arv Prnt2d1p
    stwi ; [Prnt2d1p]++
Prnt2d1b: ; W1 = number or rest
    lwr w1
    xa
    lbv '0'
    add
    xa ; X = decimal char
    arv Prnt2d1p
    lwi
    stwr w2
    ara
    xa
    stbi ; [[Prnt2d1p]]=decimal char
    lwr w2
    xa
    lwv 1
    add
    stwr w0
    ret

Prnt2d1n:   .dw 0
Prnt2d1p:   .dw 0

; Divide a 2-digit decimal number (actually up to 159) in L by 10
; Result in W3, Rest in W0. Clobbers all regs
; ---------------------------------------------------------------
Div2d10:
    zxbw    ; make sure we also handle byte inputs
    stwr w0 ; w0 = long division source accumulator
    lbv 80  ; use LBV since H is already 0 anyway
    stwr w1 ; w1 = shifted divider
    lbv 8
    stwr w2 ; w2 = result bit
    zero
    stwr w3 ; w3 = result accumulator
Div2d10l:
    lwr w1
    xa
    lwr w0  ; A = source accum, X = shifted divider
    sub
    arv Div2d10s
    jif xnz
    stwr w0 ; store subtraction result back
    lwr w2
    xa
    lwr w3
    add
    stwr w3 ; add to result
Div2d10s:
    lwr w1
    zxwx
    ror
    stwr w1 ; divider >>= 1
    lwr w2
    ror ; no need to zero X, most of its bits are still zero
    arv Div2d10e
    jif z
    stwr w2 ; result bit >>= 1
    arv Div2d10l
    jmp
Div2d10e:
    ret


; Print Hex Word. Value to print is in A, clobber W0,W1
; -----------------------------------------------------
PrntHexW:
    stwr w1
    xhl
    arv PrntHexB
    call
    lwr w1
    arv PrntHexB
    call
    ret

; Print Hex Byte. Value to print is in A, clobber W0
; --------------------------------------------------
PrntHexB:
    zxbw
    stwr w0
    ror
    ror
    ror
    ror
    arv PrntHexN
    call
    lwr w0
    arv PrntHexN
    call
    ret

; Print Hex Nibble. Value to print is in lowest 4 bits of A
; ---------------------------------------------------------
PrntHexN:
    xa
    lwv $F
    and ; [A] = nibble
    xa ; nibble in X
    lwv 10
    xa
    sub
    arv PrntHxNA
    jif xz
    xa
    lwv '0'+10 ; add 10 back
    add
    arv 1
    out
    ret
PrntHxNA: ; A..F ([A] = nibble-10, clobber X,ADDR)
    xa
    lwv 'A'
    add
    arv 1
    out
    ret

; Print zero-terminated string pointed to by A. Clobbers W1, W0
; -------------------------------------------------------------
PrintStr:
    stwr w1 ; W1 = running_ptr
    ara
    lbi
    arv PrintStx
    jif lz
    arv 1
    out
    lwr w1 ; A = running_ptr
    cxwx ; X = running_ptr
    lwv 1 ; A = 1
    add ; A = ++running ptr
    arv PrintStr
    jmp
PrintStx:
    ret
